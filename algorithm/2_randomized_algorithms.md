# 2 概率分析和随机算法

## 2.1 概念和理论

### 2.1.1 问题引入

- 雇佣问题

  有n个排队的候选办公助理，需要对每个面试，每面试完一个，如果面试完的这个比当前办公助理更好，就雇佣TA并且替换掉当前的办公助理。雇佣一个助理要花较多的钱，面试一个助理要花较少的钱。

  在雇佣问题中我们可以假设应聘者以随机顺序出现（假设不同应聘者之间是可比较的），那么n个应聘者比较出来的排列，在n!种可能出现的排列中，构成一个均匀随机排列。

  在这个问题中，容易理解，最好的应聘者在第一位是最佳情况，完全的顺序是最坏情况。

  在这个问题中，看起来应聘者好像以随机顺序出现，但我们无法确定。我们可以设计一个随机算法，对应聘者次序进行控制，**加强随机次序**。

- 随机算法

  一般的，如果一个算法的行为不仅由输入决定，而且也由**随机数生成器（random-number generator）**产生的数决定，则称这个算法是**随机的（randomized）**。

  假设 `RANDOM(a, b)` 返回一个介于 a 和 b 之间的整数，并且每个整数以等概率出现。

  在实践中，大多数编程环境会提供一个**伪随机数生成器**。

  分析一个随机算法运行时间时，我们以运行时间的期望值衡量，其中输入值由随机数生成器产生。随机算法的运行时间称为**期望运行时间**。

  一般而言，当概率分布是在算法的输入上时，我们讨论的是平均情况运行时间；当算法本身做出随机选择时，我们讨论其期望运行时间。

### 2.1.2 指示器随机变量

指示器随机变量（indicator random variable）为概率和期望之间的转换提供了一个便利的方法。

- 定义

  给定一个样本空间 $S$ 和一个事件 $A$，那么事件 $A$ 对应的指示器随机变量 ${\rm I}\lbrace A \rbrace$ 定义为：

  $${\rm I}\lbrace A \rbrace=
  \begin{cases}
  1 & 如果 A 发生 \\
  0 & 如果 A 不发生
  \end{cases}
  $$

- 引理

  给定一个样本空间 $S$ 和 $S$ 中的一个事件 $A$，设 $X_A={\rm I}\lbrace A \rbrace$，那么 $E[X_A]=\Pr{\lbrace A \rbrace}$.

- 例

  抛一次一枚硬币，正面朝上的期望次数就是指示器变量的期望值.

  抛n次一枚硬币，证明朝上的期望次数就是n个指示器随机变量总和的期望值，也就是n个指示器随机变量期望值的总和.

- 对雇佣问题的分析

  我们希望计算雇用一个新的办公助理的期望次数。

  设 $X$ 是一个随机变量，其值等于我们雇用一个新办公助理的次数。

  然后，应用期望值的定义，得到

  $$E[X]=\sum_{x=1}^n x{\rm Pr}\lbrace X=x \rbrace$$

  但是这种计算会很麻烦，取而代之，我们将采用指示器随机变量来大大简化计算。

  定义 $n$ 个变量，与每个应聘者是否被雇用对应。特别地，假设 $X_i$ 对应于第 $i$ 个应聘者被雇用该事件的指示器随机变量。因而，

  $$X_i={\rm I}\lbrace 应聘者\;i\;被雇用 \rbrace=
  \begin{cases}
  1 & 如果应聘者\;i\;被雇用 \\
  0 & 如果应聘者\;i\;不被雇用
  \end{cases}$$

  以及

  $$X=X_1+X_2+\cdots+X_n$$

  根据引理，我们有

  $$E[X_i]={\rm Pr}\lbrace 应聘者\;i\;被雇用 \rbrace$$

  应聘者 $i$ 被雇用，正好应聘者比从 $1$ 到 $i-1$ 的每一个应聘者优秀。因为我们已经假设应聘者以随机顺序出现，所以前 $i$ 个应聘者也以随机次序出现。这些前 $i$ 个应聘者中的任意一个都等可能地是目前最有资格的。应聘者 $i$ 比应聘者 $1$ 到 $i-1$ 更有资格的概率是 $1/i$，因而也以 $1/i$ 的概率被雇用。再由引理，可得

  $$E[X_i]=1/i$$

  现在可以计算 $E[X]$：

  $$\begin{aligned}
  E[X] & =E\left[\sum_{i=1}^nX_i\right] \\
  & =\sum_{i=1}^nE[X_i] \\
  & =\sum_{i=1}^n1/i \\
  & =\ln n+O(1)
  \end{aligned}$$

  尽管我们面试了 $n$ 个人，但平均起来，实际上大约只雇用他们之中的 $\ln n$ 个人。所以总的雇用费用平均情形下为 $O(c_k \ln n)$，其中 $c_k$ 是雇用一个助理需要花费的钱.

### 2.1.3 随机算法

- 随机算法与概率分析之间的区别

  向如上面一样，对问题的输入进行概率分析的方法，称为概率分析方法。

  然而在上面的雇用问题分析中，我们假设了候选人的每种排列情况是等概率分布的，实际问题中，输入的分布很可能是未知的。

  此外，考虑在雇用问题中，不论输入的分布如何，我们都将输入随机打乱为一个序列。此时，我们让随机发生在算法上，而不是在输入分布上。没有特别地输入会引出它的最坏情况行为，因为随机排列使得输入次序不再相关。只有在随机数生成器产生一个“不走运”的排列时，随机算法才会运行得很差。

- 随机排列数组

  很多随机算法通过对给定的输入变换排列以使输入随机化。这里，我们将讨论两种随机化的方法。
  
  不失一般性，假设给定一个数组 $A$，包含元素 $1$ 到 $n$。我们的目标是构造这个数组的一个随机排列。

  一个通常的方法是为数组的每个元素 $A[i]$ 赋一个随机的优先级 $P[i]$，然后依据优先级对数组 $A$ 中的元素进行排序。例如，如果初始数组 $A=<1,2,3,4>$，随机选择优先级 $P=<36,3,62,19>$，则将产生一个数组 $B=<2,4,1,3>$。我们称这个过程为 PERMUTE-BY-SORTING：

  ```
  PERMUTE-BY-SORTING(A)
  1 n = A.length
  2 let P[1..n] be a new array
  3 for i = 1 to n
  4     P[i] = RANDOM(1,n^3)
  5 sort A, using P as sort keys  
  ```

  需要证明这个过程能产生一个均匀随机排列。证明过程略，方法是证明每一种排列方式产生的概率是 $1/n!$。

  产生随机排列的一个更好的方法是原址排列给定数组。过程 RANDOMIZE-IN-PLACE 在 $O(n)$ 时间内完成。

  ```
  RANDOMIZE-IN-PLACE(A)
  1 n = A.length
  2 for i = 1 to n
  3     swap A[i] with A[RANDOM(i, n)]
  ```

  需要证明这个过程能产生一个均匀随机排列。证明过程略，方法是数学归纳法。

## 2.2 应用

### 2.2.1 生日悖论

一个屋子里人数必须要达到多少人，才能使其中两人生日相同的机会达到 $50\%$？

利用指示器随机变量分析，可以给出比直接的概率分析更简洁的近似分析。

### 2.2.2 球与箱子

把相同的球随机投到 $b$ 个箱子里，每次投球球等可能落在每一个箱子中。我们需要投多少个秋，才能使每个箱子里至少有一个球？

略

### 2.2.3 特征序列

抛掷一枚标准的硬币 $n$ 次，最长连续正面的序列的期望长度有多长？

也可以用指示器随机变量做近似分析，略

### 2.2.4 在线雇用问题

略



